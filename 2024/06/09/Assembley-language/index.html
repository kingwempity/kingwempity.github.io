<!DOCTYPE html>
<html lang="en">
    <head prefix="og: https://ogp.me/ns#">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="color-scheme" content="light dark">
  
  <title>Assembley_language - 敬请T期待</title>
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    <link rel='manifest' href='/manifest.json'>
  

  
  
  
  <meta property="og:title" content="Assembley_language - 敬请T期待" />
  
  <meta property="og:type" content="article" />
  
  <meta property="og:url" content="https://kingwempity.github.io/2024/06/09/Assembley-language/index.html" />
  
  <meta property="og:image" content="/favicon.png" />
  
  <meta property="og:article:published_time" content="2024-06-09T08:29:27.000Z" />
  
  <meta property="og:article:author" content="kingwempity" />
  
  

  
<link rel="stylesheet" href="/css/var.css">

  
<link rel="stylesheet" href="/css/main.css">

  
<link rel="stylesheet" href="/css/typography.css">

  
<link rel="stylesheet" href="/css/code-highlighting.css">

  
<link rel="stylesheet" href="/css/components.css">

  
<link rel="stylesheet" href="/css/nav.css">

  
<link rel="stylesheet" href="/css/paginator.css">

  
<link rel="stylesheet" href="/css/footer.css">

  
<link rel="stylesheet" href="/css/post-list.css">

  
  
<link rel="stylesheet" href="/css/rainbow-banner.css">

  
  
  
<link rel="stylesheet" href="/css/toc.css">

  
  
  
  
  
<link rel="stylesheet" href="/css/post.css">

  
  
  
  
  

  
<meta name="generator" content="Hexo 7.0.0"></head>
    <body
        data-color-scheme="auto"
        data-uppercase-categories="true"
        
        data-rainbow-banner="true"
        data-rainbow-banner-shown="auto"
        data-rainbow-banner-month="6"
        data-rainbow-banner-colors="#e50000,#ff8d00,#ffee00,#008121,#004cff,#760188"
        
        data-config-root="/"
        
        data-toc="true"
        data-toc-max-depth="2"
        
        
    >
        <nav id="theme-nav">
    <div class="inner">
        <a class="title" href="/">Blog</a>
        <div class="nav-arrow"></div>
        <div class="nav-items">
            <a class="nav-item nav-item-home" href="/">Home</a>
            
            
            <a class="nav-item" href="/archives">Archives</a>
            
            
            
            <a class="nav-item" href="/friends">Friends</a>
            
            
            
            <a class="nav-item" href="/projects">Projects</a>
            
            
            
            <a class="nav-item" href="/about">About</a>
            
            
            
            <a class="nav-item nav-item-github nav-item-icon" href="https://github.com/MrWillCom" target="_blank" aria-label="GitHub">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-codepen nav-item-icon" href="https://codepen.io/mrwillcom" target="_blank" aria-label="CodePen">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-patreon nav-item-icon" href="https://www.patreon.com/MrWillCom" target="_blank" aria-label="Patreon">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-mastodon nav-item-icon" href="https://noc.social/@MrWillCom" target="_blank" aria-label="Mastodon">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-discord nav-item-icon" href="https://discord.gg/UKuFDjcfY8" target="_blank" aria-label="Discord">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-search nav-item-icon" href="/search" target="_blank" aria-label="Search">&nbsp;</a>
            
            
        </div>
    </div>
</nav>
        
<article class="post">
    <div class="meta">
        
        <div class="categories text-uppercase">
        
            <a href="/categories/Languages/">Languages</a>
        
        </div>
        

        
        <div class="date" id="date">
            <span>June</span>
            <span>9,</span>
            <span>2024</span>
        </div>
        

        <h1 class="title">Assembley_language</h1>
    </div>

    <div class="divider"></div>

    <div class="content">
        <meta name="referrer" content="no-referrer">

<h1 id="1-第一章基础知识"><a href="#1-第一章基础知识" class="headerlink" title="1.第一章基础知识"></a>1.第一章基础知识</h1><h2 id="1-1-机器语言"><a href="#1-1-机器语言" class="headerlink" title="1.1.机器语言"></a>1.1.机器语言</h2><p>机器语言就是机器指令的集合，机器指令展开来讲就是一台机器可以正确执行的命令</p>
<h2 id="1-2-汇编语言的产生"><a href="#1-2-汇编语言的产生" class="headerlink" title="1.2.汇编语言的产生"></a>1.2.汇编语言的产生</h2><p>汇编指令和机器指令的差别在于指令的表示方法上，汇编指令是机器指令便于记忆的书写格式</p>
<blockquote>
<p>操作 ：寄存器BX内容送到AX中</p>
<p>机器指令：1000100111011000</p>
<p>汇编指令：mov ax，bx</p>
</blockquote>
<p>因为计算机只能读懂机器指令，需要使用编译器将汇编指令编译成机器指令</p>
<p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/a1.png" alt="a1"></p>
<h2 id="1-3-存储器"><a href="#1-3-存储器" class="headerlink" title="1.3.存储器"></a>1.3.存储器</h2><p>就是我们平常所说的内存</p>
<h2 id="1-4-存储单元"><a href="#1-4-存储单元" class="headerlink" title="1.4.存储单元"></a>1.4.存储单元</h2><p>存储器会被划分若干个存储单元</p>
<h2 id="1-5-CPU对存储器的读写"><a href="#1-5-CPU对存储器的读写" class="headerlink" title="1.5.CPU对存储器的读写"></a>1.5.CPU对存储器的读写</h2><p>通过地址总线，数据总线，控制总线对存储芯片中的数据进行读写</p>
<h2 id="1-6-主板"><a href="#1-6-主板" class="headerlink" title="1.6.主板"></a>1.6.主板</h2><p>每一台PC中，都有一个主板，通过地址总线，数据总线，控制总线将核心器件和主要器件进行相连</p>
<h2 id="1-7-接口卡"><a href="#1-7-接口卡" class="headerlink" title="1.7.接口卡"></a>1.7.接口卡</h2><p>计算机系统中，所有可用程序控制其工作的设备，必须收到CPU控制，CPU对外部设备都不能直接控制，比如显示器，音响，打印机等，直接控制这些设备进行工作的是<code>插在扩展插槽上的接口卡</code>，扩展插槽通过总线和CPU相连，接口卡也通过总线和CPU进行相连。<strong>CPU通过总线向接口卡发送命令，接口卡根据CPU的命令控制外设进行工作</strong></p>
<h2 id="1-8-各类存储器芯片"><a href="#1-8-各类存储器芯片" class="headerlink" title="1.8.各类存储器芯片"></a>1.8.各类存储器芯片</h2><p>一个PC中装有多个存储器芯片，从读写属性中分为</p>
<ul>
<li>RAM（随机存储器）：必须带电存储，关机后存储的内容丢失<ul>
<li>第一种:存放CPU和绝大部分程序和数据，主随机存储器一般由两个位置上的RAM组成，装在主板上的RAM和装在扩展槽上的RAM</li>
<li>第二种：接口卡上的RAM：某些接口需要对大批量数据，数据数据进行暂时存储，在其上安装RAM，最典型的就是显卡上的RAM，称之为<strong>显存</strong>，将要写入的内容写入显存中，显示卡随时将显存的数据在显示器上输出</li>
</ul>
</li>
<li>ROM（只读存储器）：只能读取，不能写入，关机之后内容不丢失<ul>
<li>装有BIOS（Basic Input&#x2F;Output System，基本输入&#x2F;输出系统）的ROM，BIOS 是主板和各类接口卡（如显卡，网卡等）厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入和输出。例如：主板的ROM中存储的主板的BIOS（系统BIOS），显卡上存储着显卡的BIOS，网卡上安装网卡的BIOS</li>
</ul>
</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/a2.png" alt="a2"></p>
<h2 id="1-9-内存地址空间"><a href="#1-9-内存地址空间" class="headerlink" title="1.9.内存地址空间"></a>1.9.内存地址空间</h2><p>上述的那些存储器，在物理上是独立的器件，但是一些两点比较相同</p>
<ul>
<li>都和CPU总线进行相连</li>
<li>CPU对它进行读写时候都是通过控制线发出内存读写命令</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1602839784794.png" alt="1602839784794"></p>
<p>在上图中，所有的物理存储器被看作一个有若干个存储单元组成的<code>逻辑存储器</code>，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间，CPU在在这段地址空间读写数据，实际上就是在相对应的物理存储器上读写数据</p>
<h2 id="1-10-总结"><a href="#1-10-总结" class="headerlink" title="1.10.总结"></a>1.10.总结</h2><blockquote>
<p><strong>总结：</strong></p>
<ol>
<li>汇编指令是机器指令的助记符，同机器指令一一对应</li>
<li>每一种CPU都有自己的汇编指令集</li>
<li>CPU可以直接使用的信息在存储器中存放</li>
<li>在存储器中指令和数据没有任何区别，都是二进制信息</li>
<li>存储单元从零开始顺序编号</li>
<li>一个存储单元可以存储8个bit，即8位二进制数</li>
<li>1Byte&#x3D;8bit 1KB&#x3D;1024B 1MB&#x3D;1024KB 1GB&#x3D;1024MB  <strong>类比：2^10 1KB 2^20 1MB 2^30 1GB</strong></li>
<li>每一个CPU芯片都有许多管脚，这些管脚和总线进行相连，也可以说，这些管脚引出总线。CPU引出3种总线的宽度标志这个CPU的不同方面的性能</li>
<li>地址总线宽度决定了CPU的寻址能力</li>
<li>数据总线的宽度决定了CPU和其它器件进行数据传送时的一次数据传送量</li>
<li>控制总线宽度决定了CPU对系统中器件的控制能力</li>
<li>内存地址空间：使用汇编语言编程时候，必须从CPU的角度考虑问题，对CPU来说，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU的寻址能力限制，这个逻辑CPU就是我们所说的内存地址空间</li>
</ol>
</blockquote>
<p><strong>习题：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/%E6%B1%87%E7%BC%96%E6%A3%80%E6%B5%8B1.1.png" alt="汇编检测1.1"></p>
<p><u>（1）1个CPU的寻址能力为8KB，那么它的地址总线的宽度为 <strong>13</strong>位。</u></p>
<p>答：8 KB&#x3D;8*1024 Byte&#x3D;2^3^*2^10^&#x3D;2^13^ Byte 所以13位</p>
<p><u>（2）1KB的存储器有 <strong>1024</strong> 个存储单元，存储单元的编号从 <strong>0</strong> 到 <strong>1023</strong> 。</u></p>
<p>答：一个存储字长为8 bit，1 KB&#x3D;1024 Byte&#x3D;1024 * 8 bit 有1024 存储单元</p>
<p>（3）1KB的存储器可以存储 <u><strong>8192（2^13）</strong></u> 个bit， <u><strong>1024</strong></u>个Byte。</p>
<p>答：1 KB&#x3D;1024 Byte&#x3D;1024 * 8 bit </p>
<p>（4）1GB是 <u><strong>1073741824 （2^30）</strong></u> 个Byte、1MB是 <strong><u>1048576（2^20）</u></strong> 个Byte、1KB是 **<u>1024（2^10）</u>**个Byte。</p>
<p>（5）8080、8088、80296、80386的地址总线宽度分别为16根、20根、24根、32根，则它们的寻址能力分别为: <u><strong>64</strong> （KB）</u>、 <u><strong>1</strong> （MB）</u>、 <u><strong>16</strong> （MB）</u>、 <u><strong>4</strong> （GB）</u>。</p>
<p>答：16根：2^16&#x3D;2^10 * 2^6  2^10是1024就是1KB   然后乘2^6 &#x3D;64 就是64KB，后面一次类推 </p>
<p>（6）8080、8088、8086、80286、80386的数据总线宽度分别为8根、8根、16根、16根、32根。则它们一次可以传送的数据为: <u><strong>1</strong> （B）</u>、 <u><strong>1</strong> （B）</u>、 <u><strong>2</strong> （B）</u>、 <u><strong>2</strong> （B）</u>、 <u><strong>4</strong> （B）</u>。</p>
<p>答：8根就是8bit&#x3D;1B ，后面一次类推</p>
<p>（7）从内存中读取1024字节的数据，8086至少要读 <u><strong>512</strong></u> 次，80386至少要读 <u><strong>256</strong></u> 次。</p>
<p>答：8086 数据总线宽度为16 1024 * 8 &#x2F;16 &#x3D; 512  80386数据总线宽度为32 1024 * 8 &#x2F;32 &#x3D; 256</p>
<p>（8）在存储器中，数据和程序以 <u><strong>二进制</strong></u> 形式存放。</p>
<h1 id="2-寄存器"><a href="#2-寄存器" class="headerlink" title="2.寄存器"></a>2.寄存器</h1><blockquote>
<p>一个CPU由运算器，控制器，寄存器等器件构成，这些器件靠内部总线进行相连。简单的说CPU中：</p>
<ul>
<li>运算器进行信息处理</li>
<li>寄存器进行信息存储</li>
<li>控制器控制各种器件进行工作</li>
<li>内部总线连接各个器件，在他们之间进行各种数据的传送</li>
</ul>
<p>寄存器是CPU中程序员可以用指令读写的部件，程序员可以通过改变各种寄存器的内容实现对CPU的控制</p>
<p>8086CPU由14个寄存器：AX，BX，CX，DX，SI，DI，SP，BP，IP，CS，SS,DS,ES,PSW</p>
</blockquote>
<h2 id="2-1-通用寄存器"><a href="#2-1-通用寄存器" class="headerlink" title="2.1.通用寄存器"></a>2.1.通用寄存器</h2><blockquote>
<p>所有的寄存器都是16位，可以存放两个字节。AX，BX，CX，DX 这4个通用寄存器，每一个寄存器可以分为两个可独立使用的8位寄存器来使用</p>
<ul>
<li>AX 可以分为AH和AL，累加器；可以与DX组合成为EAX&lt;&#x3D;&gt;DX:AX</li>
<li>CX可以分为CH和CL，计数器</li>
<li>DX可以分为DH和DL，累加器扩展</li>
<li>BX可以分为BH和BL，基址;可以和CX组合成为EBX&lt;&#x3D;&gt;CX:BX</li>
<li>BP基指针</li>
<li>SI源变址</li>
<li>DI目的变址</li>
<li>SP堆栈指针</li>
</ul>
</blockquote>
<h2 id="2-2-物理地址"><a href="#2-2-物理地址" class="headerlink" title="2.2.物理地址"></a>2.2.物理地址</h2><blockquote>
<p>CPU访问内存单元，要给出内存单元的地址。没一个内存单元在这个空间中都有一个唯一的地址，我们将这个唯一的地址称之为<code>物理地址</code></p>
</blockquote>
<h2 id="2-3-8086CPU给出物理地址的方法"><a href="#2-3-8086CPU给出物理地址的方法" class="headerlink" title="2.3.8086CPU给出物理地址的方法"></a>2.3.8086CPU给出物理地址的方法</h2><p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1603261636487.png" alt="1603261636487"></p>
<ol>
<li>CPU中的相关部件提供两个16位地址，一个称之为段地址，一个称之为偏移地址</li>
<li>段地址和偏移地址通过内部总线送入一个称之为地址加法器的部件</li>
<li>地址加法器将两个16位地址合成一个20位的物理地址</li>
<li>地址加法器通过内部总线将20位物理地址送入到输入和输出控制电路</li>
<li>输入和输出控制电路将20 位物理地址送上地址总线</li>
<li>20位物理地址被地址总线传送到存储器</li>
</ol>
<p><strong>地址加法器采用：</strong></p>
<p><strong>物理地址&#x3D;段地址*16+偏移地址</strong>[这里的16是十进制]</p>
<p><strong>物理地址&#x3D;段地址*(10)H+偏移地址</strong>[这里的10是十六进制]</p>
<h2 id="2-4-段的概念"><a href="#2-4-段的概念" class="headerlink" title="2.4.段的概念"></a>2.4.段的概念</h2><p>在编程时可以根据需要，将若干地址连续的内存单元看作一个段。偏移地址位16位，16位地址的最大寻址能力位64KB，所以要给段的长度最大位64KB</p>
<h2 id="2-5-段寄存器"><a href="#2-5-段寄存器" class="headerlink" title="2.5.段寄存器"></a>2.5.段寄存器</h2><blockquote>
<p>段寄存器：CS、DS、SS、ES</p>
<p>CS:<strong>代码段寄存器</strong></p>
<p>DS:<strong>数据段寄存器</strong></p>
<p>ES:<strong>附加段寄存器</strong></p>
<p>SS:<strong>堆栈段寄存器</strong></p>
<p>IP：<strong>指令指针寄存器</strong></p>
</blockquote>
<h2 id="2-6-CS和IP"><a href="#2-6-CS和IP" class="headerlink" title="2.6.CS和IP"></a>2.6.CS和IP</h2><p>假设CS中的内容位M，IP中内容位N，8086CPU将从内存M✖16+N单元开始，读取一条指令并执行</p>
<blockquote>
<p><strong>CPU将CS：IP指向内存单元中的内容看作指令</strong></p>
</blockquote>
<h2 id="2-7-总结"><a href="#2-7-总结" class="headerlink" title="2.7.总结"></a>2.7.总结</h2><blockquote>
<ul>
<li>CS 存放指令的段地址，IP存放指令的偏移地址，任意时刻，CPU将CS:IP指向内容当作指令的执行</li>
<li>CPU工作的流程</li>
<li>从CS：IP指向内存单元读取指令，读取的指令进入指令的缓冲器</li>
<li>IP指向下一条指令</li>
<li>执行指令</li>
</ul>
</blockquote>
<p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1603262922153.png" alt="1603262922153"></p>
<h2 id="2-8-Debug"><a href="#2-8-Debug" class="headerlink" title="2.8.Debug"></a>2.8.Debug</h2><ul>
<li>R命令查看、改变CPU寄存器的内容</li>
<li>D命令查看内存中的内容</li>
<li>E命令改写内存中的内容</li>
<li>U命令将内存中的机器指令翻译成汇编指令</li>
<li>T命令执行一条机器指令s</li>
<li>A命令已汇编指令的格式在内存中写入一条机器指令</li>
</ul>
<blockquote>
<p>DEBUG调试命令中的标志表示</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="left">名称</th>
<th align="left">标志为1</th>
<th align="left">标志为0</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">OF</td>
<td align="left">溢出标志(Overflow flag)</td>
<td align="left">OF&#x3D;1|是(OV)</td>
<td align="left">否(NV)</td>
<td>运算结果超出机器用补码所能表示的范围，则为溢出</td>
</tr>
<tr>
<td align="center">DF</td>
<td align="left">方向标志(Direction flag)</td>
<td align="left">DF&#x3D;1|递减(DN)</td>
<td align="left">递增(UP)</td>
<td>DF为串操作指定规定增减方向</td>
</tr>
<tr>
<td align="center">TF</td>
<td align="left">陷阱标志(Trap flag)</td>
<td align="left">TF&#x3D;1|产生中断</td>
<td align="left">未产生中断</td>
<td>TF供调试指令程序使用</td>
</tr>
<tr>
<td align="center">IF</td>
<td align="left">中断标志(Interrupt flag)</td>
<td align="left">IF&#x3D;1|允许(EI)</td>
<td align="left">关闭(DI)</td>
<td>可用开中断指令STI和关中断指令CLI设置IF的状态</td>
</tr>
<tr>
<td align="center">SF</td>
<td align="left">符号标志(Sign flag)</td>
<td align="left">SF&#x3D;1|负(NG)</td>
<td align="left">正(PL)</td>
<td>运算结果的正负</td>
</tr>
<tr>
<td align="center">ZF</td>
<td align="left">零标志(Zero flag)</td>
<td align="left">ZF&#x3D;1|是(ZR)</td>
<td align="left">否(NZ)</td>
<td>运算结果全为0则ZF置1，否则置0</td>
</tr>
<tr>
<td align="center">AF</td>
<td align="left">辅助进位标志(Auxiliary carry flag)</td>
<td align="left">AF&#x3D;1|有(AC)</td>
<td align="left">无(NA)</td>
<td>进行算数运算时，低半字节向高半字节产生进位(加法)或借位(减法)则AF&#x3D;1，否则为0</td>
</tr>
<tr>
<td align="center">PF</td>
<td align="left">奇偶标志(Parity flag)</td>
<td align="left">PF&#x3D;1|偶(PE)</td>
<td align="left">奇(PO)</td>
<td>操作结果中低八位中含1的个数的奇偶性，对应1的个数为偶数则PF&#x3D;1；</td>
</tr>
<tr>
<td align="center">CF</td>
<td align="left">进位标志(Carry flag)</td>
<td align="left">CF&#x3D;1|是(CY)</td>
<td align="left">否(NC)</td>
<td>算数运算时，最高位产生进位或借位，则CF&#x3D;1</td>
</tr>
</tbody></table>
</blockquote>
<h1 id="3-寄存器-内存访问"><a href="#3-寄存器-内存访问" class="headerlink" title="3.寄存器(内存访问)"></a>3.寄存器(内存访问)</h1><h2 id="3-1-内存中的字存储"><a href="#3-1-内存中的字存储" class="headerlink" title="3.1.内存中的字存储"></a>3.1.内存中的字存储</h2><p>CPU中用16位寄存器存储一个字，高8位存放高位字节，低8位存放低位字节。<strong>内存单元是字节单元，一个单元存放一个字节，一个字需要使用两个连续的内存单元进行存放</strong>，这个字的低位字节存放在低地址单元，高位字节存放在高地址单元。<strong>双字需要使用四个连续的内存单元进行存放</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1603853188787.png" alt="1603853188787"></p>
<p><strong>问题：</strong></p>
<ol>
<li>0地址单元存放的<u>字节型</u>数据是多少？<strong>20 H</strong></li>
<li>0地址单元存放的<u>字型</u>数据是多少？<strong>4E20 H</strong></li>
<li>2地址单元存放的<u>字节型</u>数据是多少？<strong>12 H</strong></li>
<li>2地址单元存放的<u>字型</u>数是多少？<strong>0012 H</strong></li>
<li>1地址单元存放的<u>字型</u>数据是多少？<strong>124E H</strong></li>
<li>0地址单元存放的<u>双字型</u>数据是多少？<strong>00124E20 H</strong></li>
</ol>
<h2 id="3-2-DS和-address"><a href="#3-2-DS和-address" class="headerlink" title="3.2.DS和[address]"></a>3.2.DS和[address]</h2><p><strong>CPU 要读写一个内存单元的时候，必须给出这个内存单元的地址。内存单元的地址由段地址和偏移地址组成。DS寄存器通常需要存放访问数据的段地址</strong></p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov bx,1000H</span><br><span class="line">mov ds,bx</span><br><span class="line">mov al,[0]</span><br><span class="line"></span><br><span class="line">[0]:表示内存单元的偏移地址</span><br><span class="line">指令执行的时候，CPU自动取DS中的数据作为内存单元的段地址</span><br><span class="line">mov al,[0]：表示数据从1000:0 单元到al 的传送</span><br></pre></td></tr></table></figure></div>

<h2 id="3-3-字的传送"><a href="#3-3-字的传送" class="headerlink" title="3.3.字的传送"></a>3.3.字的传送</h2><p>CPU是16位结构，有16根数据线，可以一次性传送16位数据，就是一个字</p>
<p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1603855203907.png" alt="1603855203907"></p>
<h2 id="3-4-数据段"><a href="#3-4-数据段" class="headerlink" title="3.4.数据段"></a>3.4.数据段</h2><p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1603855360712.png" alt="1603855360712"></p>
<p><strong>总结</strong></p>
<blockquote>
<ol>
<li>字在内存中存储，使用两个地址连续的内存单元存放，低位字节存放在低地址单元，高位字节存放在高地址单元</li>
<li>双字在内存中存储，使用四个地址连续的内存单元存放，即两个字型数据的存储单元</li>
<li>使用mov指令访问内存单元，可以在mov指令中只给出单元的偏移地址，此时段地址默认在DS寄存器中</li>
<li>[address]表示一个偏移地址位address的内存单元，例如[2]表示偏移地址为2的内存单元</li>
<li>在内存和寄存器之间传动数据的时候，高地址单元和高8位寄存器相对应，低地址单元和低8位寄存器相对应</li>
</ol>
</blockquote>
<h2 id="3-5-栈"><a href="#3-5-栈" class="headerlink" title="3.5.栈"></a>3.5.栈</h2><ol>
<li>入栈：就是将一个新的元素放到栈顶，栈顶指针减小；</li>
<li>出栈：就是从栈顶取出一个新的元素，栈顶指针增大；</li>
<li>栈顶的元素总是LIFO(Last In First Out)：“先进后出”；</li>
</ol>
<h2 id="3-6-CPU提供栈机制"><a href="#3-6-CPU提供栈机制" class="headerlink" title="3.6.CPU提供栈机制"></a>3.6.CPU提供栈机制</h2><p>基本命令就是PUSH和POP，push ax 表示将寄存器ax中的数据送入栈中，pop ax 表示从栈顶中取出数据送入到ax，CPU入栈和出栈操作都是以字为单位进行的。</p>
<p><strong>段寄存器SS和SP，栈顶的段地址存放在SS中，偏移地址存放在SP中，任意时刻SS:SP指向栈顶元素</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1603856276469.png" alt="1603856276469"></p>
<h2 id="3-7-栈顶超解问题"><a href="#3-7-栈顶超解问题" class="headerlink" title="3.7.栈顶超解问题"></a>3.7.栈顶超解问题</h2><p>CPU不会保证我们对栈的操作不会超界。CPU只知道栈顶(SS:SP)在何处,不知道安排的栈的空间由多大。所以编程的时候操心栈顶超界的问题。</p>
<h2 id="3-8-栈的总结"><a href="#3-8-栈的总结" class="headerlink" title="3.8.栈的总结"></a>3.8.栈的总结</h2><blockquote>
<ol>
<li>在ss,sp中存放栈顶的段地址和偏移地址：提供入栈和出栈的指令，他们根据SS:SP指示的地址，按照栈的方式访问内存单元</li>
<li>push指令的执行步骤：①sp&#x3D;sp-2 ②向ss:sp指向的字单元中送入数据</li>
<li>pop指令的执行步骤：①从ss：sp指向的字单元中读取数据②sp&#x3D;sp+2</li>
<li>任意时刻，ss：sp指向栈顶元素</li>
<li>CPU只记录栈顶，栈空间的大小由我们自己管理</li>
<li>用栈来暂存以后需要恢复的寄存器的内容时，寄存器出栈的顺序要和入栈的相反</li>
<li>push，pop实质是一种内存传送指令，注意他们灵活使用</li>
</ol>
<p><strong>总结：栈是一种非常重要的机制，一定要深入理解，灵活掌握</strong></p>
</blockquote>
<h2 id="3-9-段的综述"><a href="#3-9-段的综述" class="headerlink" title="3.9.段的综述"></a>3.9.段的综述</h2><blockquote>
<p>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元</p>
<p>我们用一个段存放数据，可以定义为 <strong>数据段</strong></p>
<p>我们用一个段存放代码，可以定义为 <strong>代码段</strong></p>
<p>我们用一个段当作栈，可以定义为 <strong>栈段</strong></p>
<p><strong>数据段</strong>：将段地址存放在DS中</p>
<p><strong>代码段</strong>：将它们的段地址存放在CS中，将段中的第一条指令的偏移地址存放在IP中，这样CPU就将执行我们定义的代码段中的指令</p>
<p><strong>栈段</strong>：段地址存放在SS中，将栈顶单元的偏移地址存放在SP中</p>
</blockquote>
<h1 id="4-第一个程序"><a href="#4-第一个程序" class="headerlink" title="4.第一个程序"></a>4.第一个程序</h1><h2 id="4-1-一个源程序从写出到执行的过程"><a href="#4-1-一个源程序从写出到执行的过程" class="headerlink" title="4.1.一个源程序从写出到执行的过程"></a>4.1.一个源程序从写出到执行的过程</h2><ul>
<li>第一步：编写汇编程序</li>
<li>第二步：对源程序进行编译连接</li>
<li>第三步：执行可执行文件中的程序</li>
</ul>
<h2 id="4-2-源程序"><a href="#4-2-源程序" class="headerlink" title="4.2.源程序"></a>4.2.源程序</h2><blockquote>
<p>汇编语言中包含两种指令：<strong>汇编指令</strong>和 <strong>伪指令</strong></p>
<ul>
<li>汇编指令：有对应机器码的指令，最终被CPU执行</li>
<li>伪指令：由编译器进行执行，进行相关的编译动作</li>
</ul>
</blockquote>
<p><strong>伪指令：</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1604027358862.png" alt="1604027358862"></p>
<p><strong>源程序中的程序</strong></p>
<p>将源程序文件中所有内容称之为源程序，然后通过编译连接后转变为机器码，存储在可执行文件中</p>
<p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1604027748325.png" alt="1604027748325"></p>
<p><strong>标号</strong></p>
<p>一个标号指代了一个地址，作为一个段的名称，这个段的名称最终会编译一个段的段地址。</p>
<p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1604028015173.png" alt="1604028015173"></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00H</span><br><span class="line">int 21H			;执行4c号功能，程序返回功能</span><br></pre></td></tr></table></figure></div>

<h1 id="5-BX-和loop指令"><a href="#5-BX-和loop指令" class="headerlink" title="5.[BX]和loop指令"></a>5.[BX]和loop指令</h1><h2 id="5-1-bx"><a href="#5-1-bx" class="headerlink" title="5.1.[bx]"></a>5.1.[bx]</h2><blockquote>
<p>mov ax,[bx]</p>
<p>说明：bx中存放的数据作为一个偏移地址EA，段地址SA默认在DS中，将SA:EA处的数据送到ax中</p>
<p>mov [bx],ax</p>
<p>说明：bx中存放的数据作为要给偏移地址EA，段地址默认在DS中，将ax中的数据送入到内存中</p>
</blockquote>
<h2 id="5-2-Loop指令"><a href="#5-2-Loop指令" class="headerlink" title="5.2.Loop指令"></a>5.2.Loop指令</h2><p>就是循环指令,它会减少CX的值并检查是否为0，如果不为0则跳转回标签继续循环。</p>
<h2 id="5-3-Loop指令和-bx-使用"><a href="#5-3-Loop指令和-bx-使用" class="headerlink" title="5.3.Loop指令和[bx]使用"></a>5.3.Loop指令和[bx]使用</h2><p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1604544565226.png" alt="1604544565226"></p>
<blockquote>
<p>这段汇编语言代码主要实现了一个简单的功能，即计算从内存中某个地址开始的12个字节数据之和，并最终通过DOS中断调用返回到操作系统。</p>
<p>下面是详细的分析和解释：</p>
<ol>
<li><p><strong>段定义</strong>:</p>
<ul>
<li><strong><code>assume cs:code</code></strong> 命令告诉汇编器代码将位于名为**<code>code</code>**的代码段中。</li>
<li><strong><code>code segment</code></strong> 和 <strong><code>code ends</code></strong> 之间的内容定义了实际的代码段。</li>
</ul>
</li>
<li><p><strong>初始化寄存器</strong>:</p>
<ul>
<li>**<code>mov ax,0fffH</code>**将十六进制数0fffH送入AX寄存器。通常，这是为了设置DS（数据段）寄存器以指向内存中的某个数据段，但此处的值似乎用于演示目的，实际上可能会导致访问内存错误，因为0fffH对于大多数程序来说不是一个有效的段地址。</li>
<li><strong><code>mov ds,ax</code></strong> 将AX的内容送入DS寄存器，设定数据段的基地址。</li>
<li><strong><code>mov bx,0</code></strong> 初始化BX为0，BX将作为偏移地址来访问内存中的数据。</li>
<li><strong><code>mov dx,0</code></strong> 初始化DX为0，DX将用来累加数据之和。</li>
<li><strong><code>mov cx,12</code></strong> <u>初始化CX为12，CX将作为循环计数器，控制循环执行12次。</u></li>
</ul>
</li>
<li><p><strong>循环求和</strong>:</p>
<ul>
<li><strong><code>s:</code></strong> 标签定义了一个循环开始的位置。</li>
<li><strong><code>mov al,[bx]</code></strong> 将BX寄存器指向的内存单元中的字节数据加载到AL寄存器中。</li>
<li><strong><code>mov ah,0</code></strong> 清零AH寄存器，确保AL中的字节数据在后续操作中被视为无符号数。</li>
<li><strong><code>add dx,ax</code></strong> 将AX寄存器的内容（此时为AL中的数据加上AH中的0）加到DX中，累计总和。</li>
<li><strong><code>inc bx</code></strong> 将BX的值增加1，以便下一次循环读取下一个字节。</li>
<li><strong><code>loop s</code></strong> 是一个循环指令，它会减少CX的值并检查是否为0，如果不为0则跳转回标签<code>s</code>继续循环。</li>
</ul>
</li>
<li><p><strong>退出程序</strong>:</p>
<ul>
<li><code>mov ax,4C00H</code> 将4C00H送入AX寄存器，这是DOS中断21H的功能号，用于请求程序终止并返回到操作系统，其中4CH表示退出程序，00H是返回给操作系统的错误码，通常表示正常退出。</li>
<li><code>int 21H</code> 执行DOS中断调用，结束程序。</li>
</ul>
</li>
</ol>
<p>注意：此代码中的DS段寄存器设置为0fffH，这在实际应用中很可能会导致访问冲突或错误，除非程序在特定的内存布局中运行，该布局中0fffH是合法且预期的数据段起始地址。在常规的实模式DOS程序中，数据段地址应由程序加载时正确设置，通常不会直接设置为这么高的地址。</p>
</blockquote>
<h2 id="5-4-段前缀"><a href="#5-4-段前缀" class="headerlink" title="5.4.段前缀"></a>5.4.段前缀</h2><ul>
<li><code>mov ax,ds:[bx]</code>:将一个内存单元的内容送入ax中，这个内存单元存放两个字节，偏移地址在<code>bx</code>中，段地址在<code>ds</code>中</li>
<li><code>mov  ax,cs:[bx]</code>,<code>mov ax,es:[bx]</code>,<code>mov ax,ss:[0]</code>,<code>mov ax,cs:[0]</code></li>
</ul>
<p>这些出现在访问内存单元的指令中，用于显示的指明内存单元的段地址的<code>ds</code>:,<code>cs:</code>,<code>ss:</code>,<code>es:</code>,我们称之为段前缀</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">段寄存器:CS、DS、ES、SS</span><br><span class="line">代码段：CS 比如：IP执行地址都是CS代码段的内容</span><br><span class="line">数据段：DS 比如：如mov ax,[bx]间接寻址法所指的都是数据段的数据</span><br><span class="line">堆栈段：SS 比如：SP堆栈数据、BP基指针，都是指堆栈段的</span><br><span class="line">附加段：ES 比如：mov ax,es:[di] 利用间接寻址法取ES段的数据</span><br></pre></td></tr></table></figure></div>

<h2 id="5-5-一段安全的段空间"><a href="#5-5-一段安全的段空间" class="headerlink" title="5.5.一段安全的段空间"></a>5.5.一段安全的段空间</h2><p><code>0:200~0:2ff</code>的256字节空间，这个段空间是安全的</p>
<h1 id="6-包含多个段的程序"><a href="#6-包含多个段的程序" class="headerlink" title="6.包含多个段的程序"></a>6.包含多个段的程序</h1><h2 id="6-1-在代码段中使用数据"><a href="#6-1-在代码段中使用数据" class="headerlink" title="6.1.在代码段中使用数据"></a>6.1.在代码段中使用数据</h2><p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1604557474529.png" alt="1604557474529"></p>
<p>**dw含义:**全称<code>define word</code>,在这里定义了8个字型数据，它们所占的内存空间大小为16字节</p>
<blockquote>
<p>程序中的指令需要对这8个数据进行累加，8个数据放在哪里呢？</p>
<p>答：程序在运行的时候CS中存放代码段的的段地址。dw定义的数据处于代码段的最开始，所以偏移地址为0，这8个数据在代码段的偏移0，2，4，6，8，A，C，E处。</p>
</blockquote>
<p><strong>ends start</strong>:指明程序的入口，被转化为一个入口地址</p>
<blockquote>
<p>这段汇编语言代码的功能是累加一组双字节（word）数据，并存储结果在寄存器AX中。下面是详细的代码分析：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br></pre></td></tr></table></figure></div>
<p>这一行声明段寄存器CS指向名为<code>code</code>的段。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">code segment</span><br><span class="line">dw  0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h</span><br></pre></td></tr></table></figure></div>
<p>定义了一个名为<code>code</code>的段，在这个段中存放了8个双字节（word）的数据：0123h, 0456h, … , 0987h。这些数据以双字节为单位连续存储在内存中，每两个数据之间默认间隔一个字节地址（因为每个数据占2字节）。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start:  mov bx,0</span><br><span class="line">mov ax,0</span><br><span class="line">mov cx,8</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>start:</code> 标记了程序的起始执行点。</li>
<li><code>mov bx,0</code> 初始化基址寄存器BX为0，BX将用来作为数据数组的指针。</li>
<li><code>mov ax,0</code> 将累加和的寄存器AX清零，用于存放最终的累加结果。</li>
<li><code>mov cx,8</code> 初始化计数寄存器CX为8，表示循环将执行8次，对应于数据数组中的8个元素。</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s:   </span><br><span class="line">add ax,[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure></div>
<p>这是一个循环结构，用以累加数据段中的所有数据：</p>
<ul>
<li><code>s:</code> 是循环的标签。</li>
<li><code>add ax,[bx]</code> 将BX指向的内存单元中的数据（当前元素）加到AX中，实现累加操作。</li>
<li><code>add bx,2</code> 每次循环后，BX增加2，这是因为每个数据项是双字节（word），即2个字节，所以要跳过当前数据到下一个数据。</li>
<li><code>loop s</code> 是循环控制指令，它会自动将CX的值减1，如果CX不为0，则跳转回标签<code>s</code>继续执行循环，直到CX减到0为止，此时循环结束。</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure></div>

<p>最后，使用DOS中断21h的服务号4Ch来结束程序，返回操作系统，其中AX寄存器的低字节00h表示程序正常退出。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>code ends</code> 表示<code>code</code>段定义结束。</li>
<li><code>end start</code> 指定程序的入口点为<code>start</code>，同时告知汇编器程序汇编结束。</li>
</ul>
<p>综上所述，这段代码的作用是从内存中预先设定的一组双字节数据（0123h至0987h）开始，将这些数据累加起来，并将累加的结果存储在AX寄存器中。</p>
</blockquote>
<h2 id="6-2-在代码段中使用栈"><a href="#6-2-在代码段中使用栈" class="headerlink" title="6.2.在代码段中使用栈"></a>6.2.在代码段中使用栈</h2><p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1604563764138.png" alt="1604563764138"></p>
<p><strong>对于sp的理解:</strong></p>
<p>第一步：看计算机系统内存：</p>
<p>SA:10: 23 12 56 04 ……….09              16个字节</p>
<p>SA:20:0…………………………..0              对应 第二个dw:00000000</p>
<p>SA:30:0…………………………..0               对应 第二个dw:00000000</p>
<blockquote>
<p>这段汇编代码完成了一个特定的任务，即通过堆栈在代码段中移动一个16字节数据块。具体分析如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assume code</span><br><span class="line">code segment</span><br><span class="line">dw 0123h,0456h,0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h</span><br><span class="line">dw 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</span><br></pre></td></tr></table></figure></div>
<p>首先，定义了两组双字节（word）数据。前8个是非零数据，后16个初始化为0。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start: mov ax,cs</span><br><span class="line">       mov  ss,ax</span><br><span class="line">       mov  sp,30h</span><br></pre></td></tr></table></figure></div>
<p>这部分代码设置了堆栈段（SS）与代码段（CS）相同，并将堆栈指针（SP）设置为30h，意味着堆栈从地址CS:30h开始向下增长，预留了一定的空间用于存储数据。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">       mov bx,0</span><br><span class="line">       mov cx,8</span><br><span class="line">s:     push cs:[bx]</span><br><span class="line">       add bx,2</span><br><span class="line">       loop s</span><br></pre></td></tr></table></figure></div>
<p>这里开始一个循环，将前8个非零数据通过<code>push</code>指令压入堆栈。<code>cs:[bx]</code>访问的是代码段中的数据，从偏移量BX开始的双字节。每次循环，BX增加2，指向下一个数据，总共循环8次，将所有非零数据压栈。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">       mov bx,0</span><br><span class="line">       mov cx,8</span><br><span class="line">s0:    pop cs:[bx]</span><br><span class="line">       add bx,2</span><br><span class="line">       loop s0</span><br></pre></td></tr></table></figure></div>
<p>接着，进行第二个循环<code>s0</code>，这次是从堆栈中弹出数据并存回到代码段中原来初始化为0的部分。同样循环8次，每次<code>pop</code>后，BX增加2，确保数据被正确地放置到代码段的对应位置。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure></div>
<p>最后，使用DOS中断21h的服务号4Ch来结束程序，返回操作系统，其中AX寄存器的低字节00h表示程序正常退出。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure></div>
<p>标记代码段结束，并告知汇编器程序的结尾。</p>
<p>总结来说，这段代码通过堆栈实现了代码段内部的数据搬移，具体是从一段非零数据移到另一段初始为0的数据区域，展示了汇编语言中堆栈操作和循环控制的应用。</p>
</blockquote>
<h2 id="6-3-将数据、代码、栈放入到不同的段"><a href="#6-3-将数据、代码、栈放入到不同的段" class="headerlink" title="6.3.将数据、代码、栈放入到不同的段"></a>6.3.将数据、代码、栈放入到不同的段</h2><p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1604564239260.png" alt="1604564239260"></p>
<p><strong>对于sp的理解</strong></p>
<p>c 等于开辟了一块空间，在这段空间中</p>
<p>SA:0:00000000</p>
<p>SA:10:000000000</p>
<p>然后就sp 就指向了20h</p>
<blockquote>
<p>这段汇编代码演示了如何在不同的段之间移动数据，具体是从数据段A到堆栈段C，然后又从堆栈段C返回到另一个位置在数据段A中。以下是详细分析：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assume cs:b,ds:a,ss:c</span><br></pre></td></tr></table></figure></div>
<p>这一行指定了代码段寄存器CS指向段b，数据段寄存器DS指向段a，堆栈段寄存器SS指向段c。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">a ends</span><br></pre></td></tr></table></figure></div>
<p>段a定义了8个双字节（word）的数据，这是原始数据集合。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">c ends</span><br></pre></td></tr></table></figure></div>
<p>段c定义了16个双字节的空数据空间，准备用于临时存储从段a中移动过来的数据。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b segment</span><br><span class="line">d:     mov ax,c</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,20h</span><br></pre></td></tr></table></figure></div>
<ul>
<li>这段代码位于代码段b中，从标号d开始执行。</li>
<li>首先，将段c的段地址加载到AX寄存器中，然后将AX的内容赋给SS，设置堆栈段指向段c。</li>
<li>接着，设置堆栈指针SP为20h，这意味着堆栈将从段c的地址20h处开始向下增长。</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,a</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:      push [bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure></div>
<ul>
<li>将段a的段地址加载到AX，再将AX赋给DS，使得数据段寄存器指向段a。</li>
<li>初始化BX为0，CX为8，用于后续循环操作。</li>
<li>进入循环s，将段a中由BX指向的数据通过<code>push</code>指令压入堆栈，之后BX加2指向下一个数据，使用<code>loop s</code>循环直到CX减到0。</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s0:    pop [bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s0</span><br></pre></td></tr></table></figure></div>
<ul>
<li>重置BX为0，CX为8，开始另一个循环s0。</li>
<li>在此循环中，从堆栈中弹出数据到段a中新的位置（之前清零的16个位置的前8个），BX每次加2指向下一个目标地址，直至循环结束。</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure></div>
<ul>
<li>最后，设置AX为4C00h，调用DOS中断21h来结束程序。</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b ends</span><br><span class="line">end   d</span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong><u>标记代码段b的结束，并告知汇编器程序的起始标签为d。</u></strong></li>
</ul>
<p>综上所述，这段代码首先设置好段寄存器以指向正确的段，然后通过堆栈机制，将段a中前8个双字节数据复制到段c中暂存，随后立即从段c中将这些数据弹出并覆盖段a中另一块预先清零的区域，完成了一次数据在段内的“转移”操作，并最终结束程序。</p>
</blockquote>
<h1 id="7-更灵活的定位内存地址的方法"><a href="#7-更灵活的定位内存地址的方法" class="headerlink" title="7.更灵活的定位内存地址的方法"></a>7.更灵活的定位内存地址的方法</h1><h2 id="7-1-and-和-or-指令、xor和not指令"><a href="#7-1-and-和-or-指令、xor和not指令" class="headerlink" title="7.1.and 和 or 指令、xor和not指令"></a>7.1.and 和 or 指令、xor和not指令</h2><blockquote>
<p><strong>and 指令：只有全为1，才为1</strong></p>
<p>mov al，01100011B</p>
<p>and  al,   00111011B</p>
<p><strong>or 指令：只用全为0，才为0</strong></p>
<p>or  al,   00111011B</p>
<p>xor cx,cx  			;CX清零，同时清除进位标志</p>
<p>AND  AX,AX		 ;自身相与值不变，该语句常用于清进位标志</p>
<p>AND AL,0FH		;分离出AL中低四位，高四位被清0</p>
<p>AND AL,0F0FH	;分离出AL中高四位，低四位被清0</p>
<p>XOR DL,80H		 ;DL中最高位置1</p>
<blockquote>
<p>总结</p>
<ul>
<li>NOT指令对标志位没有影响</li>
<li>执行除NOT指令外的逻辑指令后，OF和CF两个标志都被清0，而AF的状态不确定，其他标志反应操作结果的状态。</li>
<li>TEST指令对两个操作数进行“与”操作，但是不保留“与”的结果，只是通过标志状态的判断，得出测试结果。</li>
</ul>
</blockquote>
</blockquote>
<h2 id="7-2-位移和循环位移"><a href="#7-2-位移和循环位移" class="headerlink" title="7.2.位移和循环位移"></a>7.2.位移和循环位移</h2><blockquote>
<p><strong>非循环移位指令：</strong></p>
<p>SAL　　——　　算术左移　　——　　最高位移入标志状态位CF，最低位补0</p>
<p>SAR　　——　　算术右移　　——　　最低位移入CF，最高位不变，最高位原来是1，右移过后最高位就补1</p>
<p>比如说：将10000000算术右移7位，应该变成11111111，而逻辑右移7位，则不考虑符号位，变为00000001</p>
<p>SHL　　——　　逻辑左移　　——　　最高位移入标志状态位CF，最低位补0</p>
<p>SHR　　——　　逻辑右移　　——　　最低位移入CF，最高位补0</p>
<p><strong>循环移位指令：</strong></p>
<p>ROL　　——　　循环左移　　——　　不带进位位的循环左移，最高位移入CF和最低位</p>
<p>ROR　　——　　循环右移　　——　　不带进位位的循环右移，最低位移入CF和最高位</p>
<p>RCL　　——　　带进位的循环左移　　——　　带进位位的循环左移，最高位移入CF，原来的CF进入最低位</p>
<p>RCR　　——　　带进位的循环右移　　——　　带进位位的循环右移，最低位移入CF，原来的CF进入最高位</p>
<blockquote>
<p>说明：</p>
<ul>
<li>CF的值总是最后一次被移入的值</li>
<li>位移指令影响标志位CF,OF,SF,ZF。而循环位移指令仅影响CF和OF位。</li>
<li>对OF位的影响：在移动1位的情况下，如果位移后的操作数是最高位改变了，OF就置1，否则置0.若位移次数大于1，那么OF 不确定。</li>
</ul>
</blockquote>
<blockquote>
<p>1、算术左移、逻辑左移</p>
<p>算术左移和逻辑左移一样都是<strong>右边补0</strong></p>
<p>[例] 00101011<br> 算术左移一位:01010110<br> 逻辑左移一位:01010110</p>
<p>2、逻辑右移：将二进制数整体右移，左边补0</p>
<p>[例]10101101逻辑右移一位为01010110</p>
<p>3、算术右移：<strong>符号位</strong>要一起移动，并且在左边补上符号位</p>
<p>[例]11100算术右移一位为11110（符号位1跟着一起移动并且左边补了1）</p>
</blockquote>
</blockquote>
<h2 id="7-3-以字符的形式给出数据"><a href="#7-3-以字符的形式给出数据" class="headerlink" title="7.3.以字符的形式给出数据"></a>7.3.以字符的形式给出数据</h2><p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1604630532787.png" alt="1604630532787"></p>
<blockquote>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br></pre></td></tr></table></figure></div>

<p>这一行定义了代码段（CS）和数据段（DS）的段寄存器分别指向名为<code>code</code>和<code>data</code>的段。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">     db &quot;unIX&quot;</span><br><span class="line">     db &quot;foRK&quot;</span><br><span class="line">   data ends</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>data segment</code> 定义了数据段的开始。</li>
<li><code>db &quot;unIX&quot;</code> 和 <code>db &quot;foRK&quot;</code> 分别定义了两个字符串常量，每个字符串包含四个字符，存储在数据段中。”unIX” 和 “foRK” 会按顺序占据内存中的位置。</li>
<li><code>data ends</code> 标志数据段的结束。</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;end start</span><br></pre></td></tr></table></figure></div>

<p>这一行指示汇编器程序的结束，并且指定程序的起始地址为 <code>start</code> 标签所在的位置。</p>
<p>总结：这个程序主要做了两件事情：定义了包含两个字符串的数据段，并在代码段中执行了一些基本的寄存器操作，最后通过调用 DOS 中断21h的4C号功能来结束程序。字符串”unIX”和”foRK”虽然被定义，但在程序中并没有被使用，它们的存在更多是为了演示数据段的定义。</p>
</blockquote>
<h2 id="7-4-bx-idata"><a href="#7-4-bx-idata" class="headerlink" title="7.4. [bx+idata]"></a>7.4. [bx+idata]</h2><p>[bx+idata]表示一个内存单元，它的偏移地址为（bx）+（itda）</p>
<h2 id="7-5-SI和DI"><a href="#7-5-SI和DI" class="headerlink" title="7.5.SI和DI"></a>7.5.SI和DI</h2><p>si 和 di 是与bx 功能相近的寄存器，si 和di 不能够分成两个8为寄存器来使用，下面是3组指令实现了相同的功能</p>
<p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1604630773520.png" alt="1604630773520"></p>
<h2 id="7-6-bx-si-和-bx-di"><a href="#7-6-bx-si-和-bx-di" class="headerlink" title="7.6.[bx + si] 和 [bx + di]"></a>7.6.[bx + si] 和 [bx + di]</h2><h2 id="7-7-bx-si-idata-和-bx-di-idata"><a href="#7-7-bx-si-idata-和-bx-di-idata" class="headerlink" title="7.7.[bx + si + idata] 和 [bx + di + idata]"></a>7.7.[bx + si + idata] 和 [bx + di + idata]</h2><h1 id="8-数据处理的两个基本问题"><a href="#8-数据处理的两个基本问题" class="headerlink" title="8.数据处理的两个基本问题"></a>8.数据处理的两个基本问题</h1><p>定义了两个描述符号：</p>
<ul>
<li>通用寄存器reg包含了：ax，bx，cx，dx，（ah，al，bh，bl，ch，cl，dh，dl），sp，bp，si，di</li>
<li>段寄存器sreg包含了：ds，ss，cs，es</li>
</ul>
<h2 id="8-1-bx，si，di-和bp-基址变址寻址"><a href="#8-1-bx，si，di-和bp-基址变址寻址" class="headerlink" title="8.1.bx，si，di 和bp[基址变址寻址]"></a>8.1.bx，si，di 和bp[基址变址寻址]</h2><blockquote>
<p>只有BX，SI，DI和BP这4 个寄存器可以用于[…]中进行内存单元寻址</p>
</blockquote>
<p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1604631336930.png" alt="1604631336930"></p>
<blockquote>
<p>在[…]中，这4个寄存器可以单个出现，或者只能以4中组合出现：bx 和 si，bx 和 di，bp 和si，bp和di，比如下面指令是正确的：</p>
</blockquote>
<p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1604631454682.png" alt="1604631454682"></p>
<blockquote>
<p><strong>只要在[…]中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在SS中，</strong>比如下面的指令</p>
</blockquote>
<p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1604631552612.png" alt="1604631552612"></p>
<h2 id="8-2-汇编语言中数据位置的表达"><a href="#8-2-汇编语言中数据位置的表达" class="headerlink" title="8.2.汇编语言中数据位置的表达"></a>8.2.汇编语言中数据位置的表达</h2><blockquote>
<p>立即数：对于直接包含在机器指令中的数据（执行前在CPU的指令缓冲器中），在汇编语言中称之为立即数，在汇编指令中直接给出</p>
</blockquote>
<p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1604631868136.png" alt="1604631868136"></p>
<blockquote>
<p>寄存器：要处理的数据在寄存器中</p>
</blockquote>
<p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1604631917384.png" alt="1604631917384"></p>
<h2 id="8-3-段地址和偏移地址"><a href="#8-3-段地址和偏移地址" class="headerlink" title="8.3.段地址和偏移地址"></a>8.3.段地址和偏移地址</h2><p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1604631953216.png" alt="1604631953216"></p>
<h2 id="8-4-寻址方式"><a href="#8-4-寻址方式" class="headerlink" title="8.4.寻址方式"></a>8.4.寻址方式</h2><p><img lazyload src="/images/loading.svg" data-src="D:/blog/source/_posts/Assembley-language/1604631995576.png" alt="1604631995576"></p>
<blockquote>
<ul>
<li>用BX,DX,SI做间址寄存器寻找操作数时，隐含规定段基址由DS提供</li>
<li>当BP做间址寄存器寻找操作数时，隐含规定段基址由SS提供</li>
</ul>
</blockquote>
<h2 id="8-5-指令要处理的数据有多长"><a href="#8-5-指令要处理的数据有多长" class="headerlink" title="8.5.指令要处理的数据有多长"></a>8.5.指令要处理的数据有多长</h2><blockquote>
<p>使用操作符X ptr 指明内存单元的长度，X 在汇编中可以指定为word 或者 byte</p>
</blockquote>
<p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1604632157945.png" alt="1604632157945"></p>
<h2 id="8-6-算术运算类指令"><a href="#8-6-算术运算类指令" class="headerlink" title="8.6.算术运算类指令"></a>8.6.算术运算类指令</h2><h3 id="ADD加法指令"><a href="#ADD加法指令" class="headerlink" title="ADD加法指令"></a>ADD加法指令</h3><p>格式：ADD	DEST,	SCR</p>
<p>功能：将源操作数SCR和目的操作数DEST相加，结果存入DEST中</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD AX,X</span><br><span class="line">ADD AL,0A4H			;十六进制开头如果是A~F，需在开头加上一个数字0，不占位</span><br></pre></td></tr></table></figure></div>

<h3 id="ADC带进位加指令"><a href="#ADC带进位加指令" class="headerlink" title="ADC带进位加指令"></a>ADC带进位加指令</h3><p>格式：ADC	DEST,	SCR</p>
<p>功能：将源操作数SCR和目的操作数DEST以及进位标志CF位相加，结果存入DEST中</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADC BX,9F88H</span><br><span class="line">ADC AX,208AH</span><br></pre></td></tr></table></figure></div>

<h3 id="XADD交换加法指令"><a href="#XADD交换加法指令" class="headerlink" title="XADD交换加法指令"></a>XADD交换加法指令</h3><p>格式：XADD	DEST,	SCR</p>
<p>功能：将源操作数SCR和目的操作数DEST相加，结果存入DEST中，原来的目的操作数DEST放入源操作数SRC中</p>
<p>DEST+SCR—&gt;DEST,    原DEST—&gt;SCR</p>
<h3 id="INC自增指令"><a href="#INC自增指令" class="headerlink" title="INC自增指令"></a>INC自增指令</h3><p>格式：INC 	DEST</p>
<p>功能：将目的操作数DEST自身增加1，结果存入DEST中，即DEST&lt;-DEST+1</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INC SI</span><br></pre></td></tr></table></figure></div>

<p>注：INC指令对CF进位标志位无影响</p>
<h3 id="SUB减法指令"><a href="#SUB减法指令" class="headerlink" title="SUB减法指令"></a>SUB减法指令</h3><p>格式：SUB	DEST,	SRC</p>
<p>功能：将目的操作数DEST内容减去源操作数SRC内容，结果输入DEST中，即DEST&lt;-DEST-SRC</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SUB EAX,EBX	;CF=1	EAX=00000034H	EBX=00000052H</span><br><span class="line">;结果为EAX=FFFFFFE2H		CF=1</span><br></pre></td></tr></table></figure></div>

<h3 id="SBB带借位减法"><a href="#SBB带借位减法" class="headerlink" title="SBB带借位减法"></a>SBB带借位减法</h3><p>格式：SBB	DEST,	SRC</p>
<p>功能：将目的操作数DEST内容减去源操作数SRC内容及CF位，结果输入DEST中，即DEST&lt;-DEST-SRC-CF</p>
<p>说明：SBB指令主要用于大于16位的多精度的减法，把低位部分相减的借位引入高位部分的减法中</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SBB AX, BX;CF=1		AX=4037H		BX=2342H</span><br><span class="line">;结果为AX=1CF4H		CF=0</span><br></pre></td></tr></table></figure></div>

<h3 id="DEC自减指令"><a href="#DEC自减指令" class="headerlink" title="DEC自减指令"></a>DEC自减指令</h3><p>格式：DEC	DEST</p>
<p>格式：将目的操作数DEST自身减1，结果存入DEST中，即DEST&lt;-DEST-1</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEC SI</span><br></pre></td></tr></table></figure></div>

<h3 id="CMP比较指令"><a href="#CMP比较指令" class="headerlink" title="CMP比较指令"></a>CMP比较指令</h3><p>格式：CMP	DEST,	SRC</p>
<p>功能：目的操作数DEST减去源操作数SRC，即DEST-SRC</p>
<p>说明：CMP比较指令将两个操作数相减，但相减的结果并不保留，两个操作数都保留原值不变，只是将相减的结果的特征反应在各个状态标志位上。</p>
<blockquote>
<p><strong>执行CMP指令后，如果标志位ZF&#x3D;1，说明被比较的两个数相等；</strong></p>
<p><strong>两个数的大小查看CF标志位，如果标志位CF&#x3D;1，说明出现借位，SRC更大；</strong></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMP AX,BX		;AX-BX</span><br><span class="line">JE	NEXT		;JE表示如果两个数相等，即AX=BX，则跳转至标号NEXT</span><br><span class="line">;JE[Jump Equal]</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>条件</th>
<th>大于</th>
<th>小于</th>
<th>等于</th>
</tr>
</thead>
<tbody><tr>
<td>带符号数</td>
<td>G</td>
<td>L</td>
<td>E</td>
</tr>
<tr>
<td>无符号数</td>
<td>A</td>
<td>B</td>
<td>E</td>
</tr>
</tbody></table>
</blockquote>
<h3 id="NEG取补指令"><a href="#NEG取补指令" class="headerlink" title="NEG取补指令"></a>NEG取补指令</h3><p>格式：NEG	DEST</p>
<p>功能：零0减去目的操作数DEST，结果存入目的操作数DEST,即DEST&lt;—0-DEST</p>
<p>说明：NEG指令是求操作数的负数，即改变操作数的符号，这对带符号数即为求其补码。NEG对标志位的影响：如果被取补的操作数非0，NEG操作后，CF置1，否则CF&#x3D;0;</p>
<h3 id="MUL无符号数乘法指令"><a href="#MUL无符号数乘法指令" class="headerlink" title="MUL无符号数乘法指令"></a>MUL无符号数乘法指令</h3><p>格式：MUL	SRC</p>
<p>功能：若SRC为字节长度，则AX&lt;—AL*SRC;若SRC为字长度，则DX:AX&lt;—AX*SRC[EAX&lt;—AX*SRC]</p>
<p>说明：乘法指令格式中只出现源操作数SRC，根据操作数的类型决定是8位乘法还是16位乘法。<u><strong>SRC不能是立即数(立即数无类型属性)</strong></u>，目的操作数（被乘数）隐含约定为累加器AL(8位乘)或AX(16位乘)，运算结果约定在AX(8位乘法的积)或EAX(16位乘法的积)</p>
<blockquote>
<p>若乘积的高半部全为0，则CF&#x3D;OF&#x3D;0</p>
<p>若乘积的高半部不全为0，则CF&#x3D;OF&#x3D;1</p>
</blockquote>
<h3 id="IMUL带符号数乘法指令"><a href="#IMUL带符号数乘法指令" class="headerlink" title="IMUL带符号数乘法指令"></a>IMUL带符号数乘法指令</h3><p>格式：IMUL	SRC</p>
<p>功能：若SRC为字节长度，则AX&lt;—AL*SRC;若SRC为字长度，则DX:AX&lt;—AX*SRC[EAX&lt;—AX*SRC]</p>
<p>说明： 乘法指令只影响进位标志位CF和溢出标志位OF。对于MUL，如果乘积的高半部(8位乘时为AH，16位乘时为DX)为零0，CF&#x3D;0，OF&#x3D;0；否则CF&#x3D;OF&#x3D;1(表示AH或DX中有乘积的有效数字)。若积的高半部是低半部的符号扩展，则CF&#x3D;OF&#x3D;0，否则CF&#x3D;OF&#x3D;1；</p>
<h3 id="DIV无符号数除法指令和IDIV带符号数除法指令"><a href="#DIV无符号数除法指令和IDIV带符号数除法指令" class="headerlink" title="DIV无符号数除法指令和IDIV带符号数除法指令"></a>DIV无符号数除法指令和IDIV带符号数除法指令</h3><p>格式：DIV	SRC；IDIV	SRC</p>
<p>div 是除法指令，使用div 做除法的时候注意以下问题</p>
<p>**<u>要求被除数默认存放在ax,或者dx和ax中，而且要求被除数的位数，必须是除数的2倍</u>**，比如说，除数位8位，被除数就为16位。为什么被除数的位数一定要为除数的2倍呢？</p>
<blockquote>
<p>因为CPU只会做加法运算，把其它一切的算法都转换成加法，比如说，除数 就先转换加法，例如36&#x2F;6  当CPU看到这个运算时，就会这样想，需要多少个6 相加才能得到36呢，然后CPU就从1个6 ，2个6………..这样一种算下去，终于最后发现原来是6个6啊，从这我们可以看出，CPU是不断的用除数相加，知道找到结果为止，这就出现问题了，如果被除数不是除数位数的2倍，再相加的过程中，就可能超出除数的位数所能表达的最大数值，从而越界，如果能保证 被除数是除数的2倍 ，这问题就能解决了，例如：8 &#x2F;5   5+ 5 &#x3D;10 超出所能表达的位数，08 &#x2F;5 就可以解决这个问题</p>
</blockquote>
<ol>
<li>除数：有8位和16位两种，在一个REG或者内存单元中</li>
<li>被除数：默认放在AX或者 DX和AX中，<strong>如果除数为8位，被除数为16位，默认在AX中存放；<u>如果除数为16位，被除数为32位，在DX和AX中存放，DX存高16位，AX存低16位</u></strong></li>
<li>商：如果除数为8位，AL存储除法操作的商，AH存储除法操作的余数；如果除数为16位，AX存储除法操作的商，DX存储除法操作的余数</li>
</ol>
<h3 id="CWB字扩展指令"><a href="#CWB字扩展指令" class="headerlink" title="CWB字扩展指令"></a>CWB字扩展指令</h3><p>格式：CWB</p>
<p>功能：对AL中的带符号数进行符号扩展。若AL&lt;0,AH &#x3D;0FFH,否则AH&#x3D;0.</p>
<blockquote>
<table>
<thead>
<tr>
<th>扩展指令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>CWB</td>
<td>AL符号扩展到AH中每一位，</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
</blockquote>
<h2 id="8-7-伪指令dd"><a href="#8-7-伪指令dd" class="headerlink" title="8.7.伪指令dd"></a>8.7.伪指令dd</h2><p>db 和 dw 定义字节型数据和字型数据，dd 用来定义dword（double world，双字）型数据</p>
<h2 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h2><p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1604634131753.png" alt="1604634131753"></p>
<p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1604634144346.png" alt="1604634144346"></p>
<h1 id="9-转义指令"><a href="#9-转义指令" class="headerlink" title="9.转义指令"></a>9.转义指令</h1><h2 id="9-1-操作符-offset"><a href="#9-1-操作符-offset" class="headerlink" title="9.1.操作符 offset"></a>9.1.操作符 offset</h2><blockquote>
<p>功能：取得标号的偏移地址</p>
</blockquote>
<p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1604906127084.png" alt="1604906127084"></p>
<p>上图的案例：取得标号start和s的偏移地址为0和3</p>
<h2 id="9-2-根据位移进行转移的jmp指令"><a href="#9-2-根据位移进行转移的jmp指令" class="headerlink" title="9.2.根据位移进行转移的jmp指令"></a>9.2.根据位移进行转移的jmp指令</h2><blockquote>
<p>jmp short 标号(转到标号处执行指令)</p>
</blockquote>
<p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1604908133361.png" alt="1604908133361"></p>
<h2 id="9-3-转移的目的地址在指令中的jmp指令"><a href="#9-3-转移的目的地址在指令中的jmp指令" class="headerlink" title="9.3.转移的目的地址在指令中的jmp指令"></a>9.3.转移的目的地址在指令中的jmp指令</h2><p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1604990737283.png" alt="1604990737283"></p>
<p>将跳转到<strong>CS:IP</strong>所在的地址</p>
<h2 id="9-4-转移指令在寄存器中的jmp指令"><a href="#9-4-转移指令在寄存器中的jmp指令" class="headerlink" title="9.4.转移指令在寄存器中的jmp指令"></a>9.4.转移指令在寄存器中的jmp指令</h2><blockquote>
<p>指令格式：jmp 16 位 reg</p>
<p>功能：(IP)&#x3D;（16位reg）</p>
</blockquote>
<h2 id="9-5-转移指令在内存中jmp指令"><a href="#9-5-转移指令在内存中jmp指令" class="headerlink" title="9.5.转移指令在内存中jmp指令"></a>9.5.转移指令在内存中jmp指令</h2><blockquote>
<p>jmp word ptr 内存单元地址（段内转移）</p>
</blockquote>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">jmp word ptr ds:[0]</span><br><span class="line">执行后，（IP）=0123H</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>jmp dword ptr 内存单元地址（段间转移）</p>
</blockquote>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">jmp dword ptr ds:[0]</span><br><span class="line"></span><br><span class="line">执行后，（cs）=0,（IP）=0123H，CS:IP指向0000:0123</span><br></pre></td></tr></table></figure></div>

<h2 id="9-6-jcxz指令"><a href="#9-6-jcxz指令" class="headerlink" title="9.6.jcxz指令"></a>9.6.jcxz指令</h2><blockquote>
<p>当（cx）不等于0时，什么也不做，程序向下执行</p>
<p>当cx&#x3D;&#x3D;0，jmp short 标号；</p>
</blockquote>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">补全编程，利用jcxz指令，实现在内存2000H段中查找第一个值为0的字节，找到后，将它的偏移地址存贮在dx中。</span></span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start: mov ax,2000h</span><br><span class="line"> mov ds,ax</span><br><span class="line"> mov bx,0</span><br><span class="line"> s: mov cl, [bx]  # 注意需要保存字节</span><br><span class="line"> mov ch,0</span><br><span class="line"> jcxz ok</span><br><span class="line"> inc bx</span><br><span class="line"> jmp short s</span><br><span class="line"> ok:mov dx,bx</span><br><span class="line"> mov ax,4c00h</span><br><span class="line"> int 21h</span><br><span class="line">code ends</span><br><span class="line">end star</span><br></pre></td></tr></table></figure></div>

<h2 id="9-7-loop指令"><a href="#9-7-loop指令" class="headerlink" title="9.7.loop指令"></a>9.7.loop指令</h2><blockquote>
<p>loop指令位循环指令，为短转移，相当于</p>
<p>(cx)–</p>
<p>if ((cx)≠0) jmp short 标号；</p>
</blockquote>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">;************************************************************</span><br><span class="line">;利用loop指令,实现在内存2000H段中查找第一个值为零的byte,找到后 </span><br><span class="line">;将它的偏移地址存储到dx中 </span><br><span class="line">;************************************************************* </span><br><span class="line">assume cs:code </span><br><span class="line"></span><br><span class="line">code segment </span><br><span class="line"></span><br><span class="line">start: </span><br><span class="line">   mov ax,2000H</span><br><span class="line">   mov ds,ax</span><br><span class="line">   mov bx,0</span><br><span class="line">s: </span><br><span class="line">   mov cl,[bx]</span><br><span class="line">   mov ch,0</span><br><span class="line">   inc cx      # 当cx为0，然后加一</span><br><span class="line">   inc bx</span><br><span class="line">   loop s     # 这边会减一，然后当cx等于0 就会直接跳到下一步ok</span><br><span class="line">ok: </span><br><span class="line">   dec bx</span><br><span class="line">   mov dx,bx</span><br><span class="line"></span><br><span class="line">   mov ax,4c00h</span><br><span class="line">   int 21h</span><br><span class="line"></span><br><span class="line">code ends </span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure></div>

<h1 id="10-CALL和RET指令"><a href="#10-CALL和RET指令" class="headerlink" title="10.CALL和RET指令"></a>10.CALL和RET指令</h1><h2 id="10-1-ret和retf指令"><a href="#10-1-ret和retf指令" class="headerlink" title="10.1.ret和retf指令"></a>10.1.ret和retf指令</h2><blockquote>
<p>CPU执行ret指令，相当于<strong>pop IP</strong></p>
<p>CPU执行retf指令，相当于<strong>pop IP 和 pop CS</strong></p>
</blockquote>
<p>监测点：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">补全程序，实现从内存1000：0000处开始执行指令。</span><br><span class="line"></span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">	db 16 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start: mov ax,stack</span><br><span class="line">	   mov ss,ax</span><br><span class="line">	   mov sp,16</span><br><span class="line">	   mov ax,1000h</span><br><span class="line">	   push ax</span><br><span class="line">	   mov ax,0</span><br><span class="line">	   push ax</span><br><span class="line">	   retf</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></div>

<h2 id="10-2-根据位移进行转移的call指令"><a href="#10-2-根据位移进行转移的call指令" class="headerlink" title="10.2.根据位移进行转移的call指令"></a>10.2.根据位移进行转移的call指令</h2><blockquote>
<p>CPU执行call 标号，相当于进行</p>
<ul>
<li>push IP</li>
<li>jmp near ptr 标号</li>
</ul>
</blockquote>
<p>检测点</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 下面程序执行后，ax中的数值是多少？</span><br><span class="line">1000：0 	mov ax,0		;读取此条指令后IP=3 ，执行完该指令后IP=3</span><br><span class="line">1000：3 	call s			;读取此条指令后IP=6 ，所以IP=6入栈，执行完该指令后IP=7，跳转到s处</span><br><span class="line">1000：6 	inc ax</span><br><span class="line">1000：7 	s:pop ax		；所以POP后，ax=6</span><br></pre></td></tr></table></figure></div>

<h2 id="10-3-转移目的地址在指令中的call指令"><a href="#10-3-转移目的地址在指令中的call指令" class="headerlink" title="10.3.转移目的地址在指令中的call指令"></a>10.3.转移目的地址在指令中的call指令</h2><blockquote>
<p>call far ptr 标号：实现段间转移。相当于进行如下操作</p>
<p>push CS</p>
<p>push IP</p>
<p>jmp far ptr 标号</p>
</blockquote>
<p>监测点</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">下面程序执行后,ax中的数值为多少?</span><br><span class="line"></span><br><span class="line">内存地址	             机器码	                  汇编指令</span><br><span class="line">1000:0	             b8 00 00                 mov ax,0</span><br><span class="line">1000:3               9a 09 00 00 10           call far ptr s </span><br><span class="line">1000:8               40                       inc ax</span><br><span class="line">1000:9               58                     s:pop ax</span><br><span class="line">                                              add ax,ax  * 8h+8h=10h</span><br><span class="line">                                              pop bx</span><br><span class="line">                                              add ax,bx  * 1000h+10h=1010h</span><br><span class="line"></span><br><span class="line">call far ptr s :此时IP为8h push 1000h push 8h</span><br></pre></td></tr></table></figure></div>

<h2 id="10-4-转移地址在寄存器中的call指令"><a href="#10-4-转移地址在寄存器中的call指令" class="headerlink" title="10.4.转移地址在寄存器中的call指令"></a>10.4.转移地址在寄存器中的call指令</h2><blockquote>
<p>指令格式：call 16位 reg</p>
<p>功能：</p>
<ul>
<li>push IP</li>
<li>jmp 16 位 reg</li>
</ul>
</blockquote>
<p>检测点</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">这儿用到了bp，除了之前这样用过bp外 [bx+bp] ，还会在栈中用到。</span><br><span class="line">比如说，堆栈中压入了很多数据或者地址，你肯定想通过SP来访问这些数据或者地址，但SP是要指向栈顶的，是不能随便乱改的，这时候你就需要使用BP，把SP的值传递给BP，通过BP来寻找堆栈里数据或者地址</span><br><span class="line"></span><br><span class="line">1000:0    mov ax,6</span><br><span class="line">1000:2    call ax	;相当于push IP=5 ,jmp ax=6 ,此指令未改变CS的值</span><br><span class="line">1000:5    inc ax	;未执行</span><br><span class="line">1000:6    mov bp,sp</span><br><span class="line">          add ax,[bp]	;相当于add ax,[sp],默认段地址ss，所以即把栈顶元素弹出和AX相加6+5=11=BH</span><br></pre></td></tr></table></figure></div>

<h2 id="10-5-转移地址在内存中的call指令"><a href="#10-5-转移地址在内存中的call指令" class="headerlink" title="10.5.转移地址在内存中的call指令"></a>10.5.转移地址在内存中的call指令</h2><blockquote>
<p>call word ptr 内存单元地址，相当于进行：</p>
<p>push IP</p>
<p>jmp word ptr 内存单元地址</p>
</blockquote>
<p>实例：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov sp,10h,</span><br><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">call word ptr ds:[0]</span><br><span class="line"></span><br><span class="line">执行后，IP=0123h，sp=10h-2=0Eh</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>call dword ptr 内存单元地址，相当于进行：</p>
<p>push CS</p>
<p>push IP</p>
<p>jmp dwod ptr 内存单元地址</p>
</blockquote>
<p>实例：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov sp,10h</span><br><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">call dword ptr ds:[0]</span><br><span class="line"></span><br><span class="line">执行后，cs=0 IP=0123h sp=10h-4=0Ch</span><br></pre></td></tr></table></figure></div>

<p>检测点</p>
<p><img lazyload src="/images/loading.svg" data-src="https://gitee.com/kingwempity/images/raw/master/images/1605247814500.png" alt="1605247814500"></p>
<hr>
<hr>
<h1 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h1><p><a href="https://kingwempity.github.io/PDF/Assembly_Languages_BY_ShuangWang.pdf">《汇编语言(第3版) 》王爽著.pdf</a></p>

    </div>

    
    <div class="about">
        <h1>About this Post</h1>
        <div class="details">
            <p>This post is written by kingwempity, licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc/4.0">CC BY-NC 4.0</a>.</p>
        </div>
        
        <p class="tags">
            
            <i class="icon"></i>
            <a href="/tags/汇编语言/" class="tag">#汇编语言</a><a href="/tags/笔记/" class="tag">#笔记</a>
        </p>
        
    </div>
    

    <div class="container post-prev-next">
        
        <a href="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="next">
            <div>
                <div class="text">
                    <p class="label">Next</p>
                    <h3 class="title">计算机网络</h3>
                </div>
            </div>
        </a>
        
        
        <a href="/2024/05/03/NISP1/" class="prev">
            <div>
                <div class="text">
                    <p class="label">Previous</p>
                    <h3 class="title">NISP1</>
                </div>
            </div>
        </a>
        
    </div>

    
        
        
    
</article>

        <footer>
    <div class="inner">
        <div class="links">
            
            <div class="group">
                <h2 class="title">Blog</h2>
                
                <a href="/" class="item">Blog</a>
                
                <a href="/archives" class="item">Archives</a>
                
                <a href="/tags" class="item">Tags</a>
                
                <a href="/categories" class="item">Categories</a>
                
                <a href="/search" class="item">Search</a>
                
                <a href="/friends" class="item">Friends</a>
                
                <a href="/projects" class="item">Projects</a>
                
                <a href="/resume" class="item">Resume</a>
                
                <a href="/about" class="item">About</a>
                
                <a href="/atom.xml" class="item">RSS</a>
                
            </div>
            
            <div class="group">
                <h2 class="title">Projects</h2>
                
                <a target="_blank" rel="noopener" href="https://github.com/MrWillCom/rsa-cli" class="item">RSA CLI</a>
                
                <a target="_blank" rel="noopener" href="https://github.com/MrWillCom/hexo-theme-cupertino" class="item">Hexo Theme Cupertino</a>
                
                <a target="_blank" rel="noopener" href="https://github.com/MrWillCom/a-calendar" class="item">A Calendar</a>
                
                <a target="_blank" rel="noopener" href="https://github.com/MrWillCom/auto-mirroring-bucket" class="item">Auto Mirroring Bucket</a>
                
            </div>
            
            <div class="group">
                <h2 class="title">Me</h2>
                
                <a target="_blank" rel="noopener" href="https://github.com/MrWillCom" class="item">GitHub</a>
                
                <a target="_blank" rel="noopener" href="https://codepen.io/mrwillcom" class="item">CodePen</a>
                
                <a target="_blank" rel="noopener" href="https://www.patreon.com/MrWillCom" class="item">Patreon</a>
                
                <a target="_blank" rel="noopener" href="https://noc.social/@MrWillCom" class="item">Mastodon</a>
                
                <a target="_blank" rel="noopener" href="https://discord.gg/UKuFDjcfY8" class="item">Discord</a>
                
                <a href="mailto:mr.will.com@outlook.com" class="item">Email</a>
                
            </div>
            
        </div>
        <span>&copy; 2025 kingwempity<br>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> </span>
        
        
            <br>
            <div class="color-scheme-toggle" role="radiogroup" id="theme-color-scheme-toggle">
                <label>
                    <input type="radio" value="light">
                    <span>Light</span>
                </label>
                <label>
                    <input type="radio" value="dark">
                    <span>Dark</span>
                </label>
                <label>
                    <input type="radio" value="auto">
                    <span>Auto</span>
                </label>
            </div>
        
    </div>
</footer>


        
<script src="/js/main.js"></script>

        
        
        

        
        <script src="https://unpkg.com/scrollreveal"></script>
        <script>
            window.addEventListener('load', () => {
                ScrollReveal({ delay: 250, reset: true, easing: 'cubic-bezier(0, 0, 0, 1)' })
                ScrollReveal().reveal('.post-list-item .cover-img img')
                ScrollReveal().reveal('.post-list-item, .card, .content p img, .content .block-large img', { distance: '60px', origin: 'bottom', duration: 800 })
            })
        </script>
        
    </body>
</html>